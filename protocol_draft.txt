Работа с сетью

- логин
client -> server
POST /session/
{
    login: "blabla",
    password: "blabla"
}

server -> client
status code: 200 + session cookie, 400


- получение сессионных данных (проверка логина)
GET /session/
client -> server
session cookie

server -> client
status code 200, 401
{
    id: 1 // id юзера
    в теории может быть что-то еще, но вряд ли
}


-  рега
-//- как с логином но запрос на /user/
и еще будет status code 409 если юзер уже сществует


- получение данных игрока
client -> server
GET /user/{id}
{
    login: "asdasd",
    score: 123123123,
        upgrades: [
            { см. мазазин  }, ... etc
        ]
}

??? что еще нужно в игроке


- получение лидерборды
GET /user/
[ {см. игрока, но без улучшений}  ]


-- игра
- синхронизация с сервером раз в N секунд
client -> server
POST /game/
{
    score: 13123123
}

server -> client
status code 200, 409
{
    score: 13120000 <- сервер отправляет значение с требуемым счетом игрока, при подозрении на читерство \\ думаю забьем на это
}

но, в теории, как бы мы могли проверить хороший ли у игрока счет
если мы знаем время прошлой проверки, знаем счет игрока на тот момент, знаем улучшения которые у него были, мы с любой момент после этого можем сказать, какой максимальный счет у него может быть, если он не совершал других покупок:
если игрок онлайн, считаем что дополнительные кликеры были всегда активны. если игрок оффлайн, то считаем что всегда неактивны (вот с этим запара, еще время последнего посещения тогда хранить, для простоты и радости юзера можем считать что доп. кликеры активны всегда)
берем апгрейды в порядке отключения, для кажого момента отключения считаем прирост очков с учетом всех модификаторов, складываем со счетом, обновляем время последней синхронизации потом выбрасываем отключенный модификатор и считаем для следующего
и так до последнего апгрейда
а потом надо учесть то что игрок мог руками накликать, 5 кликов в секунду например * цена клика * время с первой синхронизации

потом сравниваем с результатом юзера. если у него меньше, он прав. если у него значительно больше, то надо ему отправить нужные очки


- получение магазина
client -> server
GET /game/shop/

server -> client
[
{
    id: 1,
    name: "Менеджер",
    cost: 100500,
    type: 1, // активный модификатор (0), пассивный (1) автокликер, дополнительный кликер (2)
    modificator: 2 // допустим, увеличивает получаемый доход в 2 раза
    или
    modificator: 1000 // каждую секунду +1000 (смотрим в зависимости от type)
    image: url,
    time: время сколько улучшение будет работать
},
... etc
]


- покупка
client -> server
POST /game/shop/
{
    id: 4
}

server -> client
status code 200, 400 // купил/не хватило денег


раз в 10 секунд например спрашиваем сервер а нет ли для нас ачивки
GET /game/achievement
[
{ 
    name: "blabla",
    description: "100500 часов игры",
    image:  
},
... etc
]

если сервер отвечает пустым массивом [] то ачивок нет :<



как хранятся данные 

SharedPreferences: настройки юзера, очки, залогинен ли
sqlite на магазин, на имеющиеся улучшения, на лидерборд ()

по хорошему нужен бы еще кэш для картинок, но сейчас не горит


в бд на сервере для каждого улучшения каждого пользователя храним время конца его работы, которое определяется как время покупки + время действия. время покупки не храним
